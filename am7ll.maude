load sequente .

mod am7ll is
    protecting SEQUENTE .
    protecting NAT .

    vars C D C' D' R S W Z : Contexto .
    vars F G H G' : Formula .
    vars P B V : Prop .

    ***Regra Inicial
    eq [Initial1] : [C] ; {F} |-- [D, F] ; {empty} = proved .
    eq [Initial2] : [C, F] ; {empty} |-- [D] ; {F} = proved .
    eq [initial3] : [C] ; {F} |-- [D] ; {F} = proved .

    ***Negação
    eq [NProp] : ~ (~ F) = F .
    eq [NTensor] : ~ (F x G) = ((~ F) 8 (~ G)) .
    eq [NPar] : ~ (F 8 G) = ((~ F) x (~ G)) .
    eq [NPlus] : ~ (F + G) = ((~ F) & (~ G)) .
    eq [NWith] : ~ (F & G) = ((~ F) + (~ G)) .
    eq [N1] : ~ 1 = I .
    eq [NI] : ~ I = 1 .
    eq [NZero] : ~ 0 = T .
    eq [NTop] : ~ T = 0 .
    eq [NBang] : ~ (! F) = ? (~ F) .
    eq [NQuestion] : ~ (? F) = ! (~ F) .

    ***Implicação
    eq [Impl] : F -o G = (~ F) 8 G .

    *** Multiplicativos
    eq [TensorL] : [C'] ; {C, (F x G)} |-- [D'] ; {D} = [C'] ; {C, F, G} |-- [D'] ; {D} .
    eq [OrMultR] : [D'] ; {D} |-- [C'] ; {F 8 G, C} = [D'] ; {D} |-- [C'] ; {F, G, C} .
    eq [BottomR] : [C'] ; {C} |-- [D'] ; {I, D} = [C'] ; {C} |-- [D'] ; {D} .
    eq [1L] : [C'] ; {C, 1} |-- [D'] ; {D} = [C'] ; {C} |-- [D'] ; {D} .
    eq [1R] : [C] ; {empty} |-- [C'] ; {1} = proved .

    *** Aditivos
    eq [AndAddR] : [C'] ; {C} |-- [D'] ; {F & G, D} =
    	[C'] ; {C} |-- [D'] ; {F, D} || [C'] ; {C} |-- [D'] ; {G, D} .
    eq [OrAddL] : [C'] ; {C, F + D} |-- [D'] ; {D} =
    	[C'] ; {C, F} |-- [D'] ; {D} || [C'] ; {C, D} |-- [D'] ; {D} .
    eq [ZeroL] : [C'] ; {C, 0} |-- [D'] ; {D} = proved .
    eq [TopR] : [C'] ; {C} |-- [D'] ; {T, D} = proved .

    *** Regra de Split -> TensorR
    --- C |-- F,W e D |-- G, Z
    rl [TensorR1] : [R] ; {C, D} |-- [S] ; {F x G, W, Z} =>
    	[R] ; {C} |-- [S] ; {F, W} || [R] ; {D} |-- [S] ; {G, Z} .
    --- C |-- F,Z e D |-- G, W
    rl [TensorR2] : [R] ; {C, D} |-- [S] ; {F x G, W, Z} =>
      [R] ; {C} |-- [S] ; {F, Z} || [R] ; {D} |-- [S] ; {G, W} .
    --- D |-- F,W e C |-- G, Z
    rl [TensorR3] : [R] ; {C, D} |-- [S] ; {F x G, W, Z} =>
    	[R] ; {D} |-- [S] ; {F, W} || [R] ; {C} |-- [S] ; {G, Z} .
    --- D |-- F,Z e C |-- G, W
    rl [TensorR4] : [R] ; {C, D} |-- [S] ; {F x G, W, Z} =>
    	[R] ; {D} |-- [S] ; {F, Z} || [R] ; {C} |-- [S] ; {G, W} .

    *** Regra de Split -> OrMultL
    --- C, F |-- W e D, G |-- Z
    rl [OrMultL1] : [R] ; {C, D, F 8 G} |-- [S] ; {W, Z} =>
    	[R] ; {C, F} |-- [S] ; {W} || [R] ; {D, G} |-- [S] ; {Z} .
    --- C, F |-- Z e D, G |-- W
    rl [OrMultL2] : [R] ; {C, D, F 8 G} |-- [S] ; {W, Z} =>
      [R] ; {C, F} |-- [S] ; {Z} || [R] ; {D, G} |-- [S] ; {W} .
    --- D, F |-- W e C, G |-- Z
    rl [OrMultL3] : [R] ; {C, D, F 8 G} |-- [S] ; {W, Z} =>
      [R] ; {D, F} |-- [S] ; {W} || [R] ; {C, G} |-- [S] ; {Z} .
    --- D, F |-- Z e C, G |-- W
    rl [OrMultL4] : [R] ; {C, D, F 8 G} |-- [S] ; {W, Z} =>
      [R] ; {D, F} |-- [S] ; {Z} || [R] ; {C, G} |-- [S] ; {W} .

    ***
    rl [OrAddR1] : [C'] ; {C} |-- [D'] ; {F + G, D} =>
    	[C'] ; {C} |-- [D'] ; {F, D} .
    rl [OrAddR2] : [C'] ; {C} |-- [D'] ; {F + G, D} =>
    	[C'] ; {C} |-- [D'] ; {G, D} .
    rl [AndAddL1] : [C'] ; {C, F & G} |-- [D'] ; {D} =>
    	[C'] ; {C, F} |-- [D'] ; {D} .
    rl [AndAddL2] : [C'] ; {C, F & G} |-- [D'] ; {D} =>
    	[C'] ; {C, G} |-- [D'] ; {D} .

    *** Storing rules
    eq [storeL] : [C] ; {! G, S} |-- [C'] ; {D'} =
    	          [C, G] ; {S} |-- [C'] ; {D'} .
    eq [storeR] : [C] ; {D} |-- [C'] ; {? G, S} =
    	          [C] ; {D} |-- [C', G] ; {S} .

    *** operators ! ?
    eq [Question] : [C] ; {empty} |-- [D] ; {! F} =
    	      [C] ; {empty} |-- [D] ; {F} .
    eq [Bang] : [C] ; {? F} |-- [D] ; {empty} =
    	      [C] ; {F} |-- [D] ; {empty} .

   *** Regras que podem causar loops (Devem ser implementadas a posteriori)
   *** rl [cpyL] : [C, F] ; {C'} |-- [D] ; {D'} => [C, F] ; {C', F} |-- [D] ; {D'} .
   *** rl [cpyR] : [C] ; [C'] |-- [D, F] ; {D'} => [C] ; [C'] |-- [D, F] ; {D', F} .
endm

--- test:
--- set trace on .
--- set trace body off .

--- Meta-Reduzindo um sequente (eq)
--- red downTerm(getTerm(metaReduce(upModule('am7ll, false),
--- upTerm("Sequente com eq"))), error) .

--- Meta-Reduzindo um sequente (rl)
--- rew downTerm(getTerm(metaXapply(upModule('am7ll, false),
--- upTerm("Sequente com rl"), '(Nome da Regra), none, 0, unbounded, 0)), error) .

*** Exemplos de substituições para TensorR e OrMultL, respectivamente.
--- red downTerm( getTerm( metaXapply ( upModule ('am7ll, false), upTerm([R] ; {p, q} |-- [S] ; {t x a, b, c}), 'TensorR1, 'C:Contexto <- 'p.Prop ; 'D:Contexto <- 'q.Prop ; 'F:Formula <- 't.Prop ; 'G:Formula <- 'a.Prop ; 'W:Contexto <- 'b.Prop ; 'Z:Contexto <- 'c.Prop, 0, unbounded, 0)), error) .
--- red downTerm( getTerm( metaXapply ( upModule ('am7ll, false), upTerm([R] ; {p, s, t 8 a} |-- [S] ; {b, c}), 'OrMultL1, 'C:Contexto <- 'p.Prop ; 'D:Contexto <- 's.Prop ; 'F:Formula <- 't.Prop ; 'G:Formula <- 'a.Prop ; 'W:Contexto <- 'b.Prop ; 'Z:Contexto <- 'c.Prop, 0, unbounded, 0)), error) .
